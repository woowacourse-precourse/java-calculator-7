# 수정 사항

### 10/16

#### 문제점

* ```//;\n1;2;3``` 값을 입력했을 때, ```NumberFormatException: 올바른 숫자 형식이 아닙니다.``` 예외처리 발생.

#### 분석

* StringParser 클래스

~~~
private List<String> parseCustomStrings(String inputStrings) {
        String[] customStrings = inputStrings.split(extractCustomDelimiter(inputStrings));
        return List.of(customStrings);
    }

    private String extractCustomDelimiter(String inputStrings) {
        return inputStrings.substring(SECOND_NUMBER, THIRD_NUMBER);
    }
~~~

해당 부분이 원인임을 찾음.

```//;\n1;2;3``` 값을 입력했을 때, ```//;\n1``` 부분이 같이 리스트에 담겨버림.

#### 해결

* 커스텀 구분자의 경우 //와 \n 사이에 어떤 값이 올지 모름. -> //와 \을 기준으로 분리 필요.
* \ 뒤에 숫자 부분 분리 필요

---

### 10/17

#### 문제점 & 분석

1. 빈값을 입력하는 경우 예외처리를 하지 않음.
2. 문자열이 "//"로 시작하면 커스텀 구분자 로직으로 넘어감 -> 커스텀 구분자 문자열 로직에는 "\\"를 이용하는 로직이 있음 -> "\\" 없다면 예외 발생시키도록 추가.

#### 해결

1. 빈 값 예외처리 진행

~~~
private void validateEmptyString(String inputStrings) {
        if (inputStrings.isEmpty()) {
            throw new IllegalArgumentException(EXCEPTION_EMPTY_STRING);
        }
    }
~~~

2. 커스텀 문자열이 "\\"를 포함하지 않을 경우 예외 처리 진행

~~~
private void validateCustomStrings(String inputStrings) {
    if (!inputStrings.contains(CUSTOM_NUMBER_DELIMITER)) {
        throw new IllegalArgumentException(EXCEPTION_STRING);
    }
}
~~~

---

#### 문제점 & 분석

~~~
if (!paresFirstString(inputStrings).equals(FIRST_CUSTOM_STRING)) {
            return parseStandardStrings(inputStrings);
        }
~~~

~~~
private String paresFirstString(String inputStrings) {
        return inputStrings.substring(INITIAL_NUMBER, SECOND_NUMBER);
    }
~~~

* 해당 로직을 하나로 합칠 수 있었다는 생각이 들었음. -> 가독성 향상

#### 해결

~~~
if (!inputStrings.startsWith(FIRST_CUSTOM_STRING)) {
            return parseStandardStrings(inputStrings);
        }
~~~

* startWith 를 사용하여 메서드를 통일하였음.

---

### 10/17

#### 문제점 & 분석

* application 예외 테스트를 진행하면서, 메서드별 단위 테스트를 안했다는 생각이 갑자기 들었음.
* 메서드 별 단위 테스트를 할 수 있도록 로직 수정 필요.
* 모든 로직 수정 필요.

#### 해결

* 먼저, 전체적인 기능 구현 목록을 수정하였다.


* StringParser
    * 생성자를 이용하여 값을 입력 받고, 그 값을 로직에 이용하였다.
  ~~~
  private final String inputStrings;

    public StringParser(String inputStrings) {
        validateEmptyString(inputStrings);
        this.inputStrings = inputStrings;
    }
  ~~~
    * 구분자를 추출하는 메서드를 생성하였다.
    * 구분자를 통해, 커스텀인지 기본구분자 경우인지 판별하여 리스트로 반환하는 메서드를 생성하였다.
    * ```public String extractDelimiter()```, ```public List<String> parseStrings(String delimiter)```
    * 내부 로직을 캡슐화 하였다.


* StringCalculator
    * 생성자를 이용하여 값을 입력 받고, 그 값을 로직에 이용하였다.
  ~~~
  private final List<String> numbers;

    public StringCalculator(List<String> numbers) {
        this.numbers = numbers;
    }
  ~~~
    * ```public int calculateStrings()``` 접근 지정자를 수정하였다.

**위 처럼 리팩토링 한 뒤 메서드 별 단위 테스트를 진행할 수 있게 되었다.**
